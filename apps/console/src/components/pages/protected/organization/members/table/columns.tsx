'use client'

import { ColumnDef } from '@tanstack/react-table'
import { AllGroupsPaginatedFieldsFragment, InviteInviteStatus, InviteRole } from '@repo/codegen/src/schema.ts'
import { Tag } from '@repo/ui/tag'
import { InviteActions } from '../actions/invite-actions'
import { formatDateSince } from '@/utils/date'
import { InvitationIconMapper } from '@/components/shared/icon-enum/invitation-enum.tsx'
import { UserRoleIconMapper } from '@/components/shared/icon-enum/user-role-enum.tsx'
import { GlobeIcon, LockIcon, StarsIcon } from 'lucide-react'
import { Badge } from '@repo/ui/badge'
import React from 'react'
import { Checkbox } from '@repo/ui/checkbox'

export type InviteNode = {
  __typename?: 'Invite' | undefined
  id: string
  recipient: string
  status: InviteInviteStatus
  createdAt?: string
  role: InviteRole
  sendAttempts?: number
}

type TGroupTableForInvitesColumns = {
  selectedGroups: AllGroupsPaginatedFieldsFragment[]
  setSelectedGroups: React.Dispatch<React.SetStateAction<AllGroupsPaginatedFieldsFragment[]>>
  allGroups: AllGroupsPaginatedFieldsFragment[]
}

export const invitesColumns: ColumnDef<InviteNode>[] = [
  {
    accessorKey: 'recipient',
    header: 'Invited user',
  },
  {
    accessorKey: 'status',
    header: 'Status',
    cell: ({ cell }) => {
      const status = cell.getValue() as InviteInviteStatus
      let statusLabel
      switch (status) {
        case InviteInviteStatus.APPROVAL_REQUIRED:
          statusLabel = 'Approval required'
          break
        case InviteInviteStatus.INVITATION_ACCEPTED:
          statusLabel = 'Accepted'
          break
        case InviteInviteStatus.INVITATION_EXPIRED:
          statusLabel = 'Expired'
          break
        case InviteInviteStatus.INVITATION_SENT:
          statusLabel = 'Outstanding'
          break
      }
      return (
        <Tag>
          <div className="flex gap-2 items-center">
            {InvitationIconMapper[status]}
            {statusLabel}
          </div>
        </Tag>
      )
    },
  },
  {
    accessorKey: 'createdAt',
    header: 'Sent',
    cell: ({ cell }) => formatDateSince(cell.getValue() as string),
  },
  {
    accessorKey: 'role',
    header: 'Role',
    cell: ({ cell }) => {
      const role = cell.getValue() as InviteRole

      return (
        <div className="flex gap-2 items-center">
          {UserRoleIconMapper[role]}
          {role}
        </div>
      )
    },
  },
  {
    accessorKey: 'sendAttempts',
    header: 'Resend Attempts',
    cell: ({ cell }) => `${cell.getValue() || 0}/5`,
  },
  {
    accessorKey: 'id',
    header: 'Action',
    cell: ({ row }) => {
      const invite = row.original
      return <InviteActions inviteId={invite.id} recipient={invite.recipient} role={invite.role} />
    },
  },
]

export const groupTableForInvitesColumns = ({ allGroups, selectedGroups, setSelectedGroups }: TGroupTableForInvitesColumns) => {
  const columns: ColumnDef<AllGroupsPaginatedFieldsFragment>[] = [
    {
      id: 'check',
      header: () => {
        const isAllGroupsSelected = allGroups.length > 0 && allGroups.every((group) => selectedGroups.some((selectedGroup) => selectedGroup.id === group.id))
        const handleSelectAll = (checked: boolean) => {
          const pagedIds = new Set(allGroups.map((i) => i.id))

          setSelectedGroups((prev) => {
            if (checked) {
              const newItems = allGroups.filter((group) => !prev.some((p) => p.id === group.id))
              return [...prev, ...newItems]
            } else {
              return prev.filter((group) => !pagedIds.has(group.id))
            }
          })
        }

        return <Checkbox checked={isAllGroupsSelected} onCheckedChange={(checked) => handleSelectAll(!!checked)} />
      },

      cell: ({ row }) => {
        const item = row.original
        const isChecked = selectedGroups.some((selectedGroup) => selectedGroup.id === item.id)

        const handleToggle = (checked: boolean) => {
          setSelectedGroups((prev) => {
            if (checked) {
              if (prev.some((p) => p.id === item.id)) return prev
              return [...prev, item]
            } else {
              return prev.filter((sel) => sel.id !== item.id)
            }
          })
        }

        return <Checkbox checked={isChecked} onCheckedChange={(checked) => handleToggle(!!checked)} />
      },
      size: 50,
    },
    {
      header: 'Name',
      accessorKey: 'name',
      cell: ({ row }) => {
        const isAutoGenerated = row.original.isManaged
        return (
          <div className="flex gap-2">
            {isAutoGenerated ? (
              <div className="flex gap-1">
                <StarsIcon className="mt-0.5" width={16} height={16} />
                <div className="flex flex-col gap-1">
                  <span className="text-sm whitespace-nowrap">{row.getValue('name')}</span>
                  <p className="text-xs text-text-light">Prebuilt</p>
                </div>
              </div>
            ) : (
              <span>{row.getValue('name')}</span>
            )}
          </div>
        )
      },
    },
    {
      header: 'Description',
      accessorKey: 'description',
      cell: ({ row }) => (
        <div>
          <p>{row.getValue('description')}</p>
          {!!row.original?.tags?.length && (
            <div className="mt-2 border-t border-dashed pt-2 flex flex-wrap gap-2">
              {row.original.tags.map((tag: string, index: number) => (
                <Badge key={index} variant="outline">
                  {tag}
                </Badge>
              ))}
            </div>
          )}
        </div>
      ),
    },
    {
      header: 'Visibility',
      accessorKey: 'visibility',
      cell: ({ row }) => {
        const value = row.original.setting?.visibility
        return (
          <span className="flex items-center gap-2 capitalize">
            {value === 'PUBLIC' ? <GlobeIcon height={18} /> : <LockIcon height={18} />}
            {value?.toLowerCase()}
          </span>
        )
      },
    },
  ]

  return columns
}
